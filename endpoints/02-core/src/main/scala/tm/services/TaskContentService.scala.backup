package tm.services

import cats.MonadThrow
import cats.implicits._
import eu.timepit.refined.types.string.NonEmptyString

import tm.domain.PersonId
import tm.domain.TaskId
import tm.domain.task._
import tm.effects.Calendar
import tm.effects.GenUUID
import tm.repositories.TaskAttachmentsRepository
import tm.repositories.TaskCommentsRepository
import tm.repositories.TasksRepository

trait TaskContentService[F[_]] {
  // Comments
  def addComment(
      taskId: TaskId,
      content: NonEmptyString,
      userId: PersonId,
      parentCommentId: Option[TaskCommentId],
    ): F[Either[TaskContentError, TaskComment]]
  def getComments(
      taskId: TaskId,
      userId: PersonId,
    ): F[Either[TaskContentError, List[TaskCommentWithAuthor]]]
  def updateComment(
      commentId: TaskCommentId,
      content: NonEmptyString,
      userId: PersonId,
    ): F[Either[TaskContentError, TaskComment]]
  def deleteComment(commentId: TaskCommentId, userId: PersonId): F[Either[TaskContentError, Unit]]

  // Attachments
  def addAttachment(
      taskId: TaskId,
      fileName: NonEmptyString,
      filePath: NonEmptyString,
      fileSize: Long,
      mimeType: Option[NonEmptyString],
      userId: PersonId,
    ): F[Either[TaskContentError, TaskAttachment]]
  def getAttachments(
      taskId: TaskId,
      userId: PersonId,
    ): F[Either[TaskContentError, List[TaskAttachment]]]
  def deleteAttachment(
      attachmentId: TaskAttachmentId,
      userId: PersonId,
    ): F[Either[TaskContentError, Unit]]
  def getAttachment(
      attachmentId: TaskAttachmentId,
      userId: PersonId,
    ): F[Either[TaskContentError, TaskAttachment]]
}

sealed trait TaskContentError
object TaskContentError {
  case object TaskNotFound extends TaskContentError
  case object CommentNotFound extends TaskContentError
  case object AttachmentNotFound extends TaskContentError
  case object AccessDenied extends TaskContentError
  case object InvalidFileSize extends TaskContentError
  case object InvalidFileType extends TaskContentError
  case class ValidationError(message: String) extends TaskContentError
}

object TaskContentService {
  def make[F[_]: MonadThrow: GenUUID: Calendar](
      commentsRepository: TaskCommentsRepository[F],
      attachmentsRepository: TaskAttachmentsRepository[F],
      tasksRepository: TasksRepository[F],
    ): TaskContentService[F] =
    new TaskContentService[F] {
      override def addComment(
          taskId: TaskId,
          content: NonEmptyString,
          userId: PersonId,
          parentCommentId: Option[TaskCommentId],
        ): F[Either[TaskContentError, TaskComment]] =
        (for {
          // Check if task exists and user has access
          taskOpt <- tasksRepository.findById(taskId)
          _ <- taskOpt.liftTo[F](new RuntimeException("Task not found"))

          // Validate parent comment if provided
          _ <- parentCommentId.fold(MonadThrow[F].unit) { parentId =>
            commentsRepository.findById(parentId).flatMap {
              case Some(parentComment) if parentComment.taskId == taskId => MonadThrow[F].unit
              case Some(_) =>
                MonadThrow[F]
                  .raiseError(new RuntimeException("Parent comment belongs to different task"))
              case None =>
                MonadThrow[F].raiseError(new RuntimeException("Parent comment not found"))
            }
          }

          // Create the comment
          commentCreate = TaskCommentCreate(taskId, content, parentCommentId)
          comment <- commentsRepository.create(commentCreate, userId)

        } yield comment.asRight[TaskContentError])
          .handleError {
            case _: RuntimeException => TaskContentError.TaskNotFound.asLeft[TaskComment]
            case _ =>
              TaskContentError.ValidationError("Failed to create comment").asLeft[TaskComment]
          }

      override def getComments(
          taskId: TaskId,
          userId: PersonId,
        ): F[Either[TaskContentError, List[TaskCommentWithAuthor]]] =
        (for {
          // Check if task exists and user has access
          taskOpt <- tasksRepository.findById(taskId)
          _ <- taskOpt.liftTo[F](new RuntimeException("Task not found"))

          // Get comments with author information
          comments <- commentsRepository.findByTaskIdWithAuthors(taskId)

        } yield comments.asRight[TaskContentError])
          .handleError(_ => TaskContentError.TaskNotFound.asLeft[List[TaskCommentWithAuthor]])

      override def updateComment(
          commentId: TaskCommentId,
          content: NonEmptyString,
          userId: PersonId,
        ): F[Either[TaskContentError, TaskComment]] =
        (for {
          // Check if comment exists and belongs to user
          commentOpt <- commentsRepository.findById(commentId)
          comment <- commentOpt.liftTo[F](new RuntimeException("Comment not found"))

          // Check ownership
          _ <-
            if (comment.authorId == userId)
              MonadThrow[F].unit
            else
              MonadThrow[F].raiseError(new RuntimeException("Access denied"))

          // Update the comment
          updatedCommentOpt <- commentsRepository.update(commentId, content)
          updatedComment <- updatedCommentOpt.liftTo[F](
            new RuntimeException("Failed to update comment")
          )

        } yield updatedComment.asRight[TaskContentError])
          .handleError {
            case _: RuntimeException => TaskContentError.CommentNotFound.asLeft[TaskComment]
            case _ =>
              TaskContentError.ValidationError("Failed to update comment").asLeft[TaskComment]
          }

      override def deleteComment(
          commentId: TaskCommentId,
          userId: PersonId,
        ): F[Either[TaskContentError, Unit]] =
        (for {
          // Check if comment exists and belongs to user or user has admin rights
          commentOpt <- commentsRepository.findById(commentId)
          comment <- commentOpt.liftTo[F](new RuntimeException("Comment not found"))

          // Check ownership (TODO: add admin/manager permissions)
          _ <-
            if (comment.authorId == userId)
              MonadThrow[F].unit
            else
              MonadThrow[F].raiseError(new RuntimeException("Access denied"))

          // Delete the comment
          deleted <- commentsRepository.delete(commentId)
          _ <-
            if (deleted) MonadThrow[F].unit
            else MonadThrow[F].raiseError(new RuntimeException("Failed to delete"))

        } yield ().asRight[TaskContentError])
          .handleError {
            case _: RuntimeException => TaskContentError.CommentNotFound.asLeft[Unit]
            case _ => TaskContentError.ValidationError("Failed to delete comment").asLeft[Unit]
          }

      override def addAttachment(
          taskId: TaskId,
          fileName: NonEmptyString,
          filePath: NonEmptyString,
          fileSize: Long,
          mimeType: Option[NonEmptyString],
          userId: PersonId,
        ): F[Either[TaskContentError, TaskAttachment]] =
        (for {
          // Check if task exists and user has access
          taskOpt <- tasksRepository.findById(taskId)
          _ <- taskOpt.liftTo[F](new RuntimeException("Task not found"))

          // Validate file size (limit: 50MB)
          _ <-
            if (fileSize > 50 * 1024 * 1024)
              MonadThrow[F].raiseError(new RuntimeException("File too large"))
            else MonadThrow[F].unit

          // Create the attachment
          attachmentCreate = TaskAttachmentCreate(taskId, fileName, filePath, fileSize, mimeType)
          attachment <- attachmentsRepository.create(attachmentCreate, userId)

        } yield attachment.asRight[TaskContentError])
          .handleError {
            case _: RuntimeException if _.getMessage.contains("File too large") =>
              TaskContentError.InvalidFileSize.asLeft[TaskAttachment]
            case _: RuntimeException => TaskContentError.TaskNotFound.asLeft[TaskAttachment]
            case _ =>
              TaskContentError.ValidationError("Failed to create attachment").asLeft[TaskAttachment]
          }

      override def getAttachments(
          taskId: TaskId,
          userId: PersonId,
        ): F[Either[TaskContentError, List[TaskAttachment]]] =
        (for {
          // Check if task exists and user has access
          taskOpt <- tasksRepository.findById(taskId)
          _ <- taskOpt.liftTo[F](new RuntimeException("Task not found"))

          // Get attachments
          attachments <- attachmentsRepository.findByTaskId(taskId)

        } yield attachments.asRight[TaskContentError])
          .handleError(_ => TaskContentError.TaskNotFound.asLeft[List[TaskAttachment]])

      override def deleteAttachment(
          attachmentId: TaskAttachmentId,
          userId: PersonId,
        ): F[Either[TaskContentError, Unit]] =
        (for {
          // Check if attachment exists
          attachmentOpt <- attachmentsRepository.findById(attachmentId)
          attachment <- attachmentOpt.liftTo[F](new RuntimeException("Attachment not found"))

          // Check if user uploaded this attachment or has admin rights (TODO: implement proper permissions)
          _ <-
            if (attachment.uploadedBy == userId)
              MonadThrow[F].unit
            else
              MonadThrow[F].raiseError(new RuntimeException("Access denied"))

          // Delete the attachment
          deleted <- attachmentsRepository.delete(attachmentId)
          _ <-
            if (deleted) MonadThrow[F].unit
            else MonadThrow[F].raiseError(new RuntimeException("Failed to delete"))

        } yield ().asRight[TaskContentError])
          .handleError {
            case _: RuntimeException => TaskContentError.AttachmentNotFound.asLeft[Unit]
            case _ => TaskContentError.ValidationError("Failed to delete attachment").asLeft[Unit]
          }

      override def getAttachment(
          attachmentId: TaskAttachmentId,
          userId: PersonId,
        ): F[Either[TaskContentError, TaskAttachment]] =
        (for {
          // Check if attachment exists
          attachmentOpt <- attachmentsRepository.findById(attachmentId)
          attachment <- attachmentOpt.liftTo[F](new RuntimeException("Attachment not found"))

          // TODO: Check if user has access to the task that owns this attachment

        } yield attachment.asRight[TaskContentError])
          .handleError(_ => TaskContentError.AttachmentNotFound.asLeft[TaskAttachment])
    }
}
