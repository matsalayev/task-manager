package tm.services

import cats.MonadThrow
import cats.implicits._

import tm.domain.PersonId
import tm.domain.ProjectId
import tm.domain.TaskId
import tm.domain.task._
import tm.repositories.TaskDependencyRepository
import tm.repositories.TasksRepository

trait TaskDependencyService[F[_]] {
  // Dependencies
  def addDependency(
      taskId: TaskId,
      request: CreateDependencyRequest,
      userId: PersonId,
    ): F[Either[DependencyError, TaskDependency]]
  def removeDependency(
      dependencyId: TaskDependencyId,
      userId: PersonId,
    ): F[Either[DependencyError, Unit]]
  def getTaskDependencies(
      taskId: TaskId,
      userId: PersonId,
    ): F[Either[DependencyError, List[TaskDependencyInfo]]]
  def getTaskDependents(
      taskId: TaskId,
      userId: PersonId,
    ): F[Either[DependencyError, List[TaskDependencyInfo]]]

  // Subtasks
  def addSubtask(
      parentTaskId: TaskId,
      request: CreateSubtaskRequest,
      userId: PersonId,
    ): F[Either[DependencyError, TaskSubtask]]
  def removeSubtask(subtaskId: TaskSubtaskId, userId: PersonId): F[Either[DependencyError, Unit]]
  def getSubtasks(
      parentTaskId: TaskId,
      userId: PersonId,
    ): F[Either[DependencyError, List[TaskSubtask]]]
  def reorderSubtasks(
      parentTaskId: TaskId,
      request: ReorderSubtasksRequest,
      userId: PersonId,
    ): F[Either[DependencyError, Unit]]

  // Advanced Operations
  def getTaskWithDependencies(
      taskId: TaskId,
      userId: PersonId,
    ): F[Either[DependencyError, TaskWithDependencies]]
  def getTaskHierarchy(taskId: TaskId, userId: PersonId): F[Either[DependencyError, TaskHierarchy]]
  def analyzeDependencies(
      projectId: Option[ProjectId],
      userId: PersonId,
    ): F[Either[DependencyError, DependencyAnalysis]]
  def getReadyTasks(
      projectId: Option[ProjectId],
      userId: PersonId,
    ): F[Either[DependencyError, List[Task]]]
  def getBlockedTasks(
      projectId: Option[ProjectId],
      userId: PersonId,
    ): F[Either[DependencyError, List[Task]]]
}

sealed trait DependencyError
object DependencyError {
  case object TaskNotFound extends DependencyError
  case object DependencyNotFound extends DependencyError
  case object SubtaskNotFound extends DependencyError
  case object AccessDenied extends DependencyError
  case object CircularDependency extends DependencyError
  case object SelfDependency extends DependencyError
  case object DependencyAlreadyExists extends DependencyError
  case object SubtaskAlreadyExists extends DependencyError
  case object InvalidHierarchy extends DependencyError
  case class ValidationError(message: String) extends DependencyError
}

object TaskDependencyService {
  def make[F[_]: MonadThrow](
      dependencyRepository: TaskDependencyRepository[F],
      tasksRepository: TasksRepository[F],
    ): TaskDependencyService[F] =
    new TaskDependencyService[F] {
      override def addDependency(
          taskId: TaskId,
          request: CreateDependencyRequest,
          userId: PersonId,
        ): F[Either[DependencyError, TaskDependency]] =
        (for {
          // Check if both tasks exist and user has access
          dependentTask <- tasksRepository
            .findById(taskId)
            .flatMap(_.liftTo[F](new RuntimeException("Dependent task not found")))
          dependencyTask <- tasksRepository
            .findById(request.dependsOnTaskId)
            .flatMap(_.liftTo[F](new RuntimeException("Dependency task not found")))

          // Validate the dependency
          validationResult <- dependencyRepository.validateDependency(
            taskId,
            request.dependsOnTaskId,
          )
          _ <-
            if (validationResult.isValid)
              MonadThrow[F].unit
            else
              MonadThrow[F].raiseError(
                new RuntimeException(validationResult.errorMessage.getOrElse("Invalid dependency"))
              )

          // Check if dependency already exists
          existingDependencies <- dependencyRepository.findDependenciesByTask(taskId)
          dependencyExists = existingDependencies.exists(
            _.dependencyTaskId == request.dependsOnTaskId
          )
          _ <-
            if (dependencyExists)
              MonadThrow[F].raiseError(new RuntimeException("Dependency already exists"))
            else MonadThrow[F].unit

          // Create the dependency
          create = TaskDependencyCreate(taskId, request.dependsOnTaskId, request.dependencyType)
          dependency <- dependencyRepository.createDependency(create)

        } yield dependency.asRight[DependencyError])
          .handleError {
            case _: RuntimeException if _.getMessage.contains("Dependent task not found") =>
              DependencyError.TaskNotFound.asLeft[TaskDependency]
            case _: RuntimeException if _.getMessage.contains("Dependency task not found") =>
              DependencyError.TaskNotFound.asLeft[TaskDependency]
            case _: RuntimeException if _.getMessage.contains("circular dependency") =>
              DependencyError.CircularDependency.asLeft[TaskDependency]
            case _: RuntimeException if _.getMessage.contains("depend on itself") =>
              DependencyError.SelfDependency.asLeft[TaskDependency]
            case _: RuntimeException if _.getMessage.contains("already exists") =>
              DependencyError.DependencyAlreadyExists.asLeft[TaskDependency]
            case _ =>
              DependencyError.ValidationError("Failed to create dependency").asLeft[TaskDependency]
          }

      override def removeDependency(
          dependencyId: TaskDependencyId,
          userId: PersonId,
        ): F[Either[DependencyError, Unit]] =
        (for {
          // Check if dependency exists
          dependencyOpt <- dependencyRepository.findDependencyById(dependencyId)
          dependency <- dependencyOpt.liftTo[F](new RuntimeException("Dependency not found"))

          // Check if user has access to the dependent task
          dependentTask <- tasksRepository
            .findById(dependency.dependentTaskId)
            .flatMap(_.liftTo[F](new RuntimeException("Access denied")))

          // TODO: Add proper permission checking based on task ownership/project membership

          // Delete the dependency
          deleted <- dependencyRepository.deleteDependency(dependencyId)
          _ <-
            if (deleted) MonadThrow[F].unit
            else MonadThrow[F].raiseError(new RuntimeException("Failed to delete"))

        } yield ().asRight[DependencyError])
          .handleError {
            case _: RuntimeException if _.getMessage.contains("Dependency not found") =>
              DependencyError.DependencyNotFound.asLeft[Unit]
            case _: RuntimeException if _.getMessage.contains("Access denied") =>
              DependencyError.AccessDenied.asLeft[Unit]
            case _ => DependencyError.ValidationError("Failed to remove dependency").asLeft[Unit]
          }

      override def getTaskDependencies(
          taskId: TaskId,
          userId: PersonId,
        ): F[Either[DependencyError, List[TaskDependencyInfo]]] =
        (for {
          // Check if task exists and user has access
          task <- tasksRepository
            .findById(taskId)
            .flatMap(_.liftTo[F](new RuntimeException("Task not found")))

          // Get dependencies
          dependencies <- dependencyRepository.findDependenciesByTask(taskId)

          // Get dependency task info
          dependencyInfos <- dependencies
            .traverse { dep =>
              tasksRepository.findById(dep.dependencyTaskId).map { taskOpt =>
                taskOpt.map { depTask =>
                  val isCompleted = isTaskCompleted(depTask.status)
                  TaskDependencyInfo(dep, depTask, isCompleted)
                }
              }
            }
            .map(_.flatten)

        } yield dependencyInfos.asRight[DependencyError])
          .handleError {
            case _: RuntimeException if _.getMessage.contains("Task not found") =>
              DependencyError.TaskNotFound.asLeft[List[TaskDependencyInfo]]
            case _ =>
              DependencyError
                .ValidationError("Failed to get dependencies")
                .asLeft[List[TaskDependencyInfo]]
          }

      override def getTaskDependents(
          taskId: TaskId,
          userId: PersonId,
        ): F[Either[DependencyError, List[TaskDependencyInfo]]] =
        (for {
          // Check if task exists and user has access
          task <- tasksRepository
            .findById(taskId)
            .flatMap(_.liftTo[F](new RuntimeException("Task not found")))

          // Get dependents
          dependents <- dependencyRepository.findDependentsByTask(taskId)

          // Get dependent task info
          dependentInfos <- dependents
            .traverse { dep =>
              tasksRepository.findById(dep.dependentTaskId).map { taskOpt =>
                taskOpt.map { depTask =>
                  val isCompleted = isTaskCompleted(depTask.status)
                  TaskDependencyInfo(dep, depTask, isCompleted)
                }
              }
            }
            .map(_.flatten)

        } yield dependentInfos.asRight[DependencyError])
          .handleError {
            case _: RuntimeException if _.getMessage.contains("Task not found") =>
              DependencyError.TaskNotFound.asLeft[List[TaskDependencyInfo]]
            case _ =>
              DependencyError
                .ValidationError("Failed to get dependents")
                .asLeft[List[TaskDependencyInfo]]
          }

      override def addSubtask(
          parentTaskId: TaskId,
          request: CreateSubtaskRequest,
          userId: PersonId,
        ): F[Either[DependencyError, TaskSubtask]] =
        (for {
          // Check if both tasks exist
          parentTask <- tasksRepository
            .findById(parentTaskId)
            .flatMap(_.liftTo[F](new RuntimeException("Parent task not found")))
          childTask <- tasksRepository
            .findById(request.childTaskId)
            .flatMap(_.liftTo[F](new RuntimeException("Child task not found")))

          // Check if child task is already a subtask of parent
          existingSubtasks <- dependencyRepository.findSubtasksByParent(parentTaskId)
          subtaskExists = existingSubtasks.exists(_.childTaskId == request.childTaskId)
          _ <-
            if (subtaskExists)
              MonadThrow[F].raiseError(new RuntimeException("Subtask already exists"))
            else MonadThrow[F].unit

          // Check if child task already has a parent
          existingParent <- dependencyRepository.findParentByChild(request.childTaskId)
          _ <- existingParent match {
            case Some(_) =>
              MonadThrow[F].raiseError(new RuntimeException("Task already has a parent"))
            case None => MonadThrow[F].unit
          }

          // Determine order index
          orderIndex = request.orderIndex.getOrElse {
            existingSubtasks.map(_.orderIndex).maxOption.getOrElse(0) + 1
          }

          // Create the subtask relationship
          create = TaskSubtaskCreate(parentTaskId, request.childTaskId, orderIndex)
          subtask <- dependencyRepository.createSubtask(create, userId)

        } yield subtask.asRight[DependencyError])
          .handleError {
            case _: RuntimeException if _.getMessage.contains("Parent task not found") =>
              DependencyError.TaskNotFound.asLeft[TaskSubtask]
            case _: RuntimeException if _.getMessage.contains("Child task not found") =>
              DependencyError.TaskNotFound.asLeft[TaskSubtask]
            case _: RuntimeException if _.getMessage.contains("already exists") =>
              DependencyError.SubtaskAlreadyExists.asLeft[TaskSubtask]
            case _: RuntimeException if _.getMessage.contains("already has a parent") =>
              DependencyError.InvalidHierarchy.asLeft[TaskSubtask]
            case _ =>
              DependencyError.ValidationError("Failed to create subtask").asLeft[TaskSubtask]
          }

      override def removeSubtask(
          subtaskId: TaskSubtaskId,
          userId: PersonId,
        ): F[Either[DependencyError, Unit]] =
        (for {
          // For now, just try to delete
          deleted <- dependencyRepository.deleteSubtask(subtaskId)
          _ <-
            if (deleted) MonadThrow[F].unit
            else MonadThrow[F].raiseError(new RuntimeException("Subtask not found"))

        } yield ().asRight[DependencyError])
          .handleError {
            case _: RuntimeException if _.getMessage.contains("Subtask not found") =>
              DependencyError.SubtaskNotFound.asLeft[Unit]
            case _ => DependencyError.ValidationError("Failed to remove subtask").asLeft[Unit]
          }

      override def getSubtasks(
          parentTaskId: TaskId,
          userId: PersonId,
        ): F[Either[DependencyError, List[TaskSubtask]]] =
        (for {
          // Check if parent task exists and user has access
          parentTask <- tasksRepository
            .findById(parentTaskId)
            .flatMap(_.liftTo[F](new RuntimeException("Task not found")))

          // Get subtasks
          subtasks <- dependencyRepository.findSubtasksByParent(parentTaskId)

        } yield subtasks.asRight[DependencyError])
          .handleError {
            case _: RuntimeException if _.getMessage.contains("Task not found") =>
              DependencyError.TaskNotFound.asLeft[List[TaskSubtask]]
            case _ =>
              DependencyError.ValidationError("Failed to get subtasks").asLeft[List[TaskSubtask]]
          }

      override def reorderSubtasks(
          parentTaskId: TaskId,
          request: ReorderSubtasksRequest,
          userId: PersonId,
        ): F[Either[DependencyError, Unit]] =
        (for {
          // Check if parent task exists and user has access
          parentTask <- tasksRepository
            .findById(parentTaskId)
            .flatMap(_.liftTo[F](new RuntimeException("Task not found")))

          // Reorder subtasks
          _ <- dependencyRepository.reorderSubtasks(parentTaskId, request.subtaskOrders)

        } yield ().asRight[DependencyError])
          .handleError {
            case _: RuntimeException if _.getMessage.contains("Task not found") =>
              DependencyError.TaskNotFound.asLeft[Unit]
            case _ => DependencyError.ValidationError("Failed to reorder subtasks").asLeft[Unit]
          }

      override def getTaskWithDependencies(
          taskId: TaskId,
          userId: PersonId,
        ): F[Either[DependencyError, TaskWithDependencies]] =
        (for {
          // Get the main task
          task <- tasksRepository
            .findById(taskId)
            .flatMap(_.liftTo[F](new RuntimeException("Task not found")))

          // Get dependencies
          dependencies <- getTaskDependencies(taskId, userId).flatMap(
            _.liftTo[F](new RuntimeException("Failed to get dependencies"))
          )

          // Get dependents
          dependents <- getTaskDependents(taskId, userId).flatMap(
            _.liftTo[F](new RuntimeException("Failed to get dependents"))
          )

          // Get subtasks recursively
          subtasks <- getSubtasks(taskId, userId).flatMap(
            _.liftTo[F](new RuntimeException("Failed to get subtasks"))
          )
          subtaskWithDeps <- subtasks.traverse(st =>
            getTaskWithDependencies(st.childTaskId, userId)
              .flatMap(_.liftTo[F](new RuntimeException("Failed to get subtask dependencies")))
          )

          // Get parent task
          parentOpt <- dependencyRepository.findParentByChild(taskId)

          // Determine if task is blocked
          isBlocked = dependencies.exists(!_.isCompleted)
          canStart = !isBlocked

        } yield TaskWithDependencies(
          task = task,
          dependencies = dependencies,
          dependents = dependents,
          subtasks = subtaskWithDeps,
          parentTask = parentOpt.map(_.parentTaskId),
          isBlocked = isBlocked,
          canStart = canStart,
        ).asRight[DependencyError])
          .handleError {
            case _: RuntimeException if _.getMessage.contains("Task not found") =>
              DependencyError.TaskNotFound.asLeft[TaskWithDependencies]
            case _ =>
              DependencyError
                .ValidationError("Failed to get task with dependencies")
                .asLeft[TaskWithDependencies]
          }

      override def getTaskHierarchy(
          taskId: TaskId,
          userId: PersonId,
        ): F[Either[DependencyError, TaskHierarchy]] =
        dependencyRepository
          .getTaskHierarchy(taskId)
          .map {
            case Some(hierarchy) => hierarchy.asRight[DependencyError]
            case None => DependencyError.TaskNotFound.asLeft[TaskHierarchy]
          }
          .handleError(_ =>
            DependencyError.ValidationError("Failed to get task hierarchy").asLeft[TaskHierarchy]
          )

      override def analyzeDependencies(
          projectId: Option[ProjectId],
          userId: PersonId,
        ): F[Either[DependencyError, DependencyAnalysis]] =
        dependencyRepository
          .analyzeDependencies(projectId)
          .map(_.asRight[DependencyError])
          .handleError(_ =>
            DependencyError
              .ValidationError("Failed to analyze dependencies")
              .asLeft[DependencyAnalysis]
          )

      override def getReadyTasks(
          projectId: Option[ProjectId],
          userId: PersonId,
        ): F[Either[DependencyError, List[Task]]] =
        (for {
          readyTaskIds <- dependencyRepository.getReadyTasks(projectId)
          readyTasks <- readyTaskIds
            .traverse(taskId => tasksRepository.findById(taskId))
            .map(_.flatten)
        } yield readyTasks.asRight[DependencyError])
          .handleError(_ =>
            DependencyError.ValidationError("Failed to get ready tasks").asLeft[List[Task]]
          )

      override def getBlockedTasks(
          projectId: Option[ProjectId],
          userId: PersonId,
        ): F[Either[DependencyError, List[Task]]] =
        (for {
          blockedTaskIds <- dependencyRepository.getBlockedTasks(projectId)
          blockedTasks <- blockedTaskIds
            .traverse(taskId => tasksRepository.findById(taskId))
            .map(_.flatten)
        } yield blockedTasks.asRight[DependencyError])
          .handleError(_ =>
            DependencyError.ValidationError("Failed to get blocked tasks").asLeft[List[Task]]
          )

      private def isTaskCompleted(status: tm.domain.enums.TaskStatus): Boolean = {
        import tm.domain.enums.TaskStatus._
        status match {
          case Done | Completed => true
          case _ => false
        }
      }
    }
}
