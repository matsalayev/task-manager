package tm.services

import cats.MonadThrow
import cats.implicits._

import tm.domain.PersonId
import tm.domain.ProjectId
import tm.domain.TaskId
import tm.domain.enums.TaskStatus
import tm.domain.task._
import tm.repositories.KanbanRepository
import tm.repositories.TasksRepository

trait KanbanService[F[_]] {
  def getKanbanBoard(projectId: ProjectId, userId: PersonId): F[Either[KanbanError, KanbanBoard]]
  def moveTask(
      taskId: TaskId,
      newStatus: TaskStatus,
      newPosition: Int,
      userId: PersonId,
    ): F[Either[KanbanError, Task]]
  def bulkMoveTask(moves: List[TaskMove], userId: PersonId): F[Either[KanbanError, Unit]]
  def reorderColumn(
      projectId: ProjectId,
      status: TaskStatus,
      taskIds: List[TaskId],
      userId: PersonId,
    ): F[Either[KanbanError, Unit]]
  def updateWipLimit(
      projectId: ProjectId,
      status: TaskStatus,
      wipLimit: Option[Int],
      userId: PersonId,
    ): F[Either[KanbanError, Unit]]
}

sealed trait KanbanError
object KanbanError {
  case object TaskNotFound extends KanbanError
  case object ProjectNotFound extends KanbanError
  case object AccessDenied extends KanbanError
  case object InvalidPosition extends KanbanError
  case object InvalidStatus extends KanbanError
  case object WipLimitExceeded extends KanbanError
  case class ValidationError(message: String) extends KanbanError
}

object KanbanService {
  def make[F[_]: MonadThrow](
      kanbanRepository: KanbanRepository[F],
      tasksRepository: TasksRepository[F],
    ): KanbanService[F] =
    new KanbanService[F] {
      override def getKanbanBoard(
          projectId: ProjectId,
          userId: PersonId,
        ): F[Either[KanbanError, KanbanBoard]] =
        (for {
          // TODO: Check if user has access to the project
          board <- kanbanRepository.getKanbanBoard(projectId)
        } yield board.asRight[KanbanError])
          .handleError(_ => KanbanError.ProjectNotFound.asLeft[KanbanBoard])

      override def moveTask(
          taskId: TaskId,
          newStatus: TaskStatus,
          newPosition: Int,
          userId: PersonId,
        ): F[Either[KanbanError, Task]] =
        (for {
          // Check if task exists and user has access
          taskOpt <- tasksRepository.findById(taskId)
          task <- taskOpt.liftTo[F](new RuntimeException("Task not found"))

          // TODO: Add permission checking based on task/project ownership

          // Validate position
          _ <-
            if (newPosition >= 0)
              MonadThrow[F].unit
            else
              MonadThrow[F].raiseError(new RuntimeException("Invalid position"))

          // Check WIP limits before moving
          _ <- validateWipLimits(task.projectId, newStatus, Some(taskId))

          // Move the task
          movedTaskOpt <- kanbanRepository.moveTask(taskId, newStatus, newPosition)
          movedTask <- movedTaskOpt.liftTo[F](new RuntimeException("Failed to move task"))

        } yield movedTask.asRight[KanbanError])
          .handleError {
            case _: RuntimeException if _.getMessage.contains("Task not found") =>
              KanbanError.TaskNotFound.asLeft[Task]
            case _: RuntimeException if _.getMessage.contains("Invalid position") =>
              KanbanError.InvalidPosition.asLeft[Task]
            case _: RuntimeException if _.getMessage.contains("WIP limit") =>
              KanbanError.WipLimitExceeded.asLeft[Task]
            case _ => KanbanError.ValidationError("Failed to move task").asLeft[Task]
          }

      override def bulkMoveTask(
          moves: List[TaskMove],
          userId: PersonId,
        ): F[Either[KanbanError, Unit]] =
        (for {
          // Validate all moves first
          _ <- moves.traverse_ { move =>
            for {
              taskOpt <- tasksRepository.findById(move.taskId)
              _ <- taskOpt.liftTo[F](new RuntimeException("Task not found"))
              _ <-
                if (move.newPosition >= 0)
                  MonadThrow[F].unit
                else
                  MonadThrow[F].raiseError(new RuntimeException("Invalid position"))
            } yield ()
          }

          // TODO: Validate WIP limits for all moves

          // Execute all moves
          _ <- kanbanRepository.bulkMoveTask(moves)

        } yield ().asRight[KanbanError])
          .handleError {
            case _: RuntimeException if _.getMessage.contains("Task not found") =>
              KanbanError.TaskNotFound.asLeft[Unit]
            case _: RuntimeException if _.getMessage.contains("Invalid position") =>
              KanbanError.InvalidPosition.asLeft[Unit]
            case _ => KanbanError.ValidationError("Failed to bulk move tasks").asLeft[Unit]
          }

      override def reorderColumn(
          projectId: ProjectId,
          status: TaskStatus,
          taskIds: List[TaskId],
          userId: PersonId,
        ): F[Either[KanbanError, Unit]] =
        (for {
          // TODO: Check if user has access to the project

          // Validate that all tasks belong to the project and status
          _ <- taskIds.traverse_ { taskId =>
            for {
              taskOpt <- tasksRepository.findById(taskId)
              task <- taskOpt.liftTo[F](new RuntimeException("Task not found"))
              _ <-
                if (task.projectId == projectId && task.status == status)
                  MonadThrow[F].unit
                else
                  MonadThrow[F].raiseError(
                    new RuntimeException("Task does not belong to project/status")
                  )
            } yield ()
          }

          // Reorder tasks
          _ <- kanbanRepository.reorderTasksInColumn(projectId, status, taskIds)

        } yield ().asRight[KanbanError])
          .handleError {
            case _: RuntimeException if _.getMessage.contains("Task not found") =>
              KanbanError.TaskNotFound.asLeft[Unit]
            case _: RuntimeException if _.getMessage.contains("does not belong") =>
              KanbanError.ValidationError("Invalid task for this column").asLeft[Unit]
            case _ => KanbanError.ValidationError("Failed to reorder column").asLeft[Unit]
          }

      override def updateWipLimit(
          projectId: ProjectId,
          status: TaskStatus,
          wipLimit: Option[Int],
          userId: PersonId,
        ): F[Either[KanbanError, Unit]] =
        (for {
          // TODO: Check if user has admin access to the project

          // Validate WIP limit value
          _ <- wipLimit.fold(MonadThrow[F].unit) { limit =>
            if (limit > 0)
              MonadThrow[F].unit
            else
              MonadThrow[F].raiseError(new RuntimeException("WIP limit must be positive"))
          }

          // Check if current task count exceeds new limit
          currentTasks <- kanbanRepository.getTasksByStatus(projectId, status)
          _ <- wipLimit.fold(MonadThrow[F].unit) { limit =>
            if (currentTasks.length <= limit)
              MonadThrow[F].unit
            else
              MonadThrow[F].raiseError(
                new RuntimeException("Current task count exceeds new WIP limit")
              )
          }

          // Update WIP limit
          _ <- kanbanRepository.updateWipLimit(projectId, status, wipLimit)

        } yield ().asRight[KanbanError])
          .handleError {
            case _: RuntimeException if _.getMessage.contains("WIP limit must be positive") =>
              KanbanError.ValidationError("WIP limit must be positive").asLeft[Unit]
            case _: RuntimeException if _.getMessage.contains("exceeds new WIP limit") =>
              KanbanError.WipLimitExceeded.asLeft[Unit]
            case _ => KanbanError.ValidationError("Failed to update WIP limit").asLeft[Unit]
          }

      private def validateWipLimits(
          projectId: ProjectId,
          targetStatus: TaskStatus,
          excludeTaskId: Option[TaskId] = None,
        ): F[Unit] =
        // TODO: Implement WIP limit validation
        // 1. Get current WIP limit for the status
        // 2. Count current tasks in that status (excluding the moved task)
        // 3. Check if adding one more task would exceed the limit
        MonadThrow[F].unit
    }
}
