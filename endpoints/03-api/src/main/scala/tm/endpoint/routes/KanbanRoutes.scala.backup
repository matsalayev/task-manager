package tm.endpoint.routes

import cats.MonadThrow
import cats.implicits._
import org.http4s._
import org.http4s.circe.CirceEntityCodec._
import org.http4s.circe.JsonDecoder
import org.typelevel.log4cats.Logger

import tm.domain.ProjectId
import tm.domain.TaskId
import tm.domain.auth.AuthedUser
import tm.domain.enums.TaskStatus
import tm.domain.task._
import tm.services.KanbanError
import tm.services.KanbanService
import tm.support.http4s.utils.Routes
import tm.support.syntax.http4s.http4SyntaxReqOps

final case class KanbanRoutes[F[_]: JsonDecoder: MonadThrow](
    kanbanService: KanbanService[F]
  )(implicit
    logger: Logger[F]
  ) extends Routes[F, AuthedUser] {
  override val path = "/kanban"

  override val public: HttpRoutes[F] = HttpRoutes.empty

  override val `private`: AuthedRoutes[AuthedUser, F] = AuthedRoutes.of {

    // Get Kanban board for a project
    case GET -> Root / "project" / UUIDVar(projectId) as user =>
      val targetProjectId = ProjectId(projectId)
      kanbanService.getKanbanBoard(targetProjectId, user.id).flatMap {
        case Right(board) => Ok(board)
        case Left(KanbanError.ProjectNotFound) => NotFound("Project not found")
        case Left(KanbanError.AccessDenied) => Forbidden("Access denied")
        case Left(error) => BadRequest(s"Error: $error")
      }

    // Move a task to a different status/position
    case ar @ PUT -> Root / "task" / UUIDVar(taskId) / "move" as user =>
      val targetTaskId = TaskId(taskId)
      ar.req.decodeR[TaskMoveRequest] { request =>
        kanbanService
          .moveTask(targetTaskId, request.newStatus, request.newPosition, user.id)
          .flatMap {
            case Right(task) => Ok(task)
            case Left(KanbanError.TaskNotFound) => NotFound("Task not found")
            case Left(KanbanError.AccessDenied) => Forbidden("Access denied")
            case Left(KanbanError.InvalidPosition) => BadRequest("Invalid position")
            case Left(KanbanError.InvalidStatus) => BadRequest("Invalid status")
            case Left(KanbanError.WipLimitExceeded) => BadRequest("WIP limit exceeded")
            case Left(KanbanError.ValidationError(msg)) => BadRequest(msg)
            case Left(error) => BadRequest(s"Error: $error")
          }
      }

    // Bulk move multiple tasks
    case ar @ PUT -> Root / "tasks" / "bulk-move" as user =>
      ar.req.decodeR[BulkTaskMoveRequest] { request =>
        kanbanService.bulkMoveTask(request.moves, user.id).flatMap {
          case Right(_) => Ok("Tasks moved successfully")
          case Left(KanbanError.TaskNotFound) => NotFound("One or more tasks not found")
          case Left(KanbanError.AccessDenied) => Forbidden("Access denied")
          case Left(KanbanError.InvalidPosition) =>
            BadRequest("Invalid position in one or more moves")
          case Left(KanbanError.WipLimitExceeded) => BadRequest("WIP limit exceeded")
          case Left(KanbanError.ValidationError(msg)) => BadRequest(msg)
          case Left(error) => BadRequest(s"Error: $error")
        }
      }

    // Reorder tasks within a column
    case ar @ PUT -> Root / "project" / UUIDVar(
           projectId
         ) / "column" / statusVar / "reorder" as user =>
      val targetProjectId = ProjectId(projectId)
      ar.req.decodeR[List[TaskId]] { taskIds =>
        kanbanService.reorderColumn(targetProjectId, statusVar, taskIds, user.id).flatMap {
          case Right(_) => Ok("Column reordered successfully")
          case Left(KanbanError.ProjectNotFound) => NotFound("Project not found")
          case Left(KanbanError.TaskNotFound) => NotFound("One or more tasks not found")
          case Left(KanbanError.AccessDenied) => Forbidden("Access denied")
          case Left(KanbanError.ValidationError(msg)) => BadRequest(msg)
          case Left(error) => BadRequest(s"Error: $error")
        }
      }

    // Update WIP limit for a column
    case ar @ PUT -> Root / "project" / UUIDVar(
           projectId
         ) / "column" / statusVar / "wip-limit" as user =>
      val targetProjectId = ProjectId(projectId)
      ar.req.decodeR[UpdateWipLimitRequest] { request =>
        kanbanService
          .updateWipLimit(targetProjectId, request.status, request.wipLimit, user.id)
          .flatMap {
            case Right(_) => Ok("WIP limit updated successfully")
            case Left(KanbanError.ProjectNotFound) => NotFound("Project not found")
            case Left(KanbanError.AccessDenied) => Forbidden("Access denied")
            case Left(KanbanError.WipLimitExceeded) =>
              BadRequest("Current task count exceeds new WIP limit")
            case Left(KanbanError.ValidationError(msg)) => BadRequest(msg)
            case Left(error) => BadRequest(s"Error: $error")
          }
      }
  }

  // Custom path variable extractor for TaskStatus
  private object statusVar {
    def unapply(str: String): Option[TaskStatus] = str match {
      case "Todo" => Some(TaskStatus.Todo)
      case "InProgress" => Some(TaskStatus.InProgress)
      case "Done" => Some(TaskStatus.Done)
      case "Completed" => Some(TaskStatus.Completed)
      case "Cancelled" => Some(TaskStatus.Cancelled)
      case _ => None
    }
  }
}
