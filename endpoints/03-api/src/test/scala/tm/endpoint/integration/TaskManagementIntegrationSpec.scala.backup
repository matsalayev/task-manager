package tm.endpoint.integration

import cats.effect.IO
import cats.implicits._
import org.http4s._
import org.http4s.circe.CirceEntityCodec._
import org.http4s.implicits._

import tm.database.DBSuite
import tm.domain.auth.AuthedUser
import tm.domain.enums.TaskStatus
import tm.domain.task._
import tm.domain.time._
import tm.generators._
import tm.test.TestSuite

object TaskManagementIntegrationSpec extends TestSuite with DBSuite {
  test("Complete task management workflow integration") {
    withFullApplication { app =>
      for {
        // Setup test data
        user <- UserGenerators.userGen.sample
        authedUser = AuthedUser(user.id, user.name, user.email)
        project <- ProjectGenerators.projectGen.sample

        // 1. Create a task
        taskCreate <- TaskGenerators.taskCreateGen.map(_.copy(projectId = project.id)).sample
        createTaskResponse <- app
          .taskRoutes
          .run(
            Request[IO](Method.POST, uri"/tasks").withEntity(taskCreate) -> authedUser
          )
          .value

        _ <- expect(createTaskResponse.isDefined).failFast
        _ <- expect(createTaskResponse.get.status == Status.Created).failFast

        createdTask <- createTaskResponse.get.as[Task]
        taskId = createdTask.id

        // 2. Add comment to task
        commentRequest = CommentCreateRequest(
          content = eu.timepit.refined.types.string.NonEmptyString.unsafeFrom("Test comment"),
          parentCommentId = None,
        )

        commentResponse <- app
          .taskContentRoutes
          .run(
            Request[IO](Method.POST, uri"/tasks" / taskId.value.toString / "comments")
              .withEntity(commentRequest) -> authedUser
          )
          .value

        _ <- expect(commentResponse.isDefined).failFast
        _ <- expect(commentResponse.get.status == Status.Created).failFast

        // 3. Add attachment to task
        attachmentRequest = AttachmentCreateRequest(
          fileName = eu.timepit.refined.types.string.NonEmptyString.unsafeFrom("test.pdf"),
          filePath = eu.timepit.refined.types.string.NonEmptyString.unsafeFrom("/uploads/test.pdf"),
          fileSize = 1024L,
          mimeType =
            Some(eu.timepit.refined.types.string.NonEmptyString.unsafeFrom("application/pdf")),
        )

        attachmentResponse <- app
          .taskContentRoutes
          .run(
            Request[IO](Method.POST, uri"/tasks" / taskId.value.toString / "attachments")
              .withEntity(attachmentRequest) -> authedUser
          )
          .value

        _ <- expect(attachmentResponse.isDefined).failFast
        _ <- expect(attachmentResponse.get.status == Status.Created).failFast

        // 4. Move task in Kanban board
        moveRequest = TaskMoveRequest(TaskStatus.InProgress, 1)

        moveResponse <- app
          .kanbanRoutes
          .run(
            Request[IO](Method.PUT, uri"/kanban" / "task" / taskId.value.toString / "move")
              .withEntity(moveRequest) -> authedUser
          )
          .value

        _ <- expect(moveResponse.isDefined).failFast
        _ <- expect(moveResponse.get.status == Status.Ok).failFast

        // 5. Start work session and timer
        sessionRequest = StartWorkSessionRequest(
          workMode = WorkMode.Remote,
          location = Some("Home"),
          description = Some("Working on task"),
        )

        sessionResponse <- app
          .timeTrackingRoutes
          .run(
            Request[IO](Method.POST, uri"/time-tracking" / "session" / "start")
              .withEntity(sessionRequest) -> authedUser
          )
          .value

        _ <- expect(sessionResponse.isDefined).failFast
        _ <- expect(sessionResponse.get.status == Status.Created).failFast

        // 6. Start timer for task
        timerRequest = StartTimerRequest(
          taskId = Some(taskId),
          description = "Working on the task",
        )

        timerResponse <- app
          .timeTrackingRoutes
          .run(
            Request[IO](Method.POST, uri"/time-tracking" / "timer" / "start")
              .withEntity(timerRequest) -> authedUser
          )
          .value

        _ <- expect(timerResponse.isDefined).failFast
        _ <- expect(timerResponse.get.status == Status.Created).failFast

        // 7. Get Kanban board to verify task status
        boardResponse <- app
          .kanbanRoutes
          .run(
            Request[IO](
              Method.GET,
              uri"/kanban" / "project" / project.id.value.toString,
            ) -> authedUser
          )
          .value

        _ <- expect(boardResponse.isDefined).failFast
        _ <- expect(boardResponse.get.status == Status.Ok).failFast

        board <- boardResponse.get.as[KanbanBoard]
        inProgressColumn = board.columns.find(_.status == TaskStatus.InProgress)
        _ <- expect(inProgressColumn.isDefined).failFast
        _ <- expect(inProgressColumn.get.tasks.exists(_.id == taskId)).failFast

        // 8. Get time dashboard
        dashboardResponse <- app
          .timeTrackingRoutes
          .run(
            Request[IO](Method.GET, uri"/time-tracking" / "dashboard") -> authedUser
          )
          .value

        _ <- expect(dashboardResponse.isDefined).failFast
        _ <- expect(dashboardResponse.get.status == Status.Ok).failFast

        dashboard <- dashboardResponse.get.as[TimeDashboard]
        _ <- expect(dashboard.currentSession.isDefined).failFast
        _ <- expect(dashboard.currentTimer.isDefined).failFast

        // 9. Create subtask
        subtask <- TaskGenerators.taskCreateGen.map(_.copy(projectId = project.id)).sample
        subtaskResponse <- app
          .taskRoutes
          .run(
            Request[IO](Method.POST, uri"/tasks").withEntity(subtask) -> authedUser
          )
          .value

        createdSubtask <- subtaskResponse.get.as[Task]

        subtaskRequest = CreateSubtaskRequest(
          childTaskId = createdSubtask.id,
          orderIndex = Some(0),
        )

        addSubtaskResponse <- app
          .dependencyRoutes
          .run(
            Request[IO](Method.POST, uri"/tasks" / taskId.value.toString / "subtasks")
              .withEntity(subtaskRequest) -> authedUser
          )
          .value

        _ <- expect(addSubtaskResponse.isDefined).failFast
        _ <- expect(addSubtaskResponse.get.status == Status.Created).failFast

        // 10. Get task hierarchy
        hierarchyResponse <- app
          .dependencyRoutes
          .run(
            Request[IO](Method.GET, uri"/tasks" / taskId.value.toString / "hierarchy") -> authedUser
          )
          .value

        _ <- expect(hierarchyResponse.isDefined).failFast
        _ <- expect(hierarchyResponse.get.status == Status.Ok).failFast

        hierarchy <- hierarchyResponse.get.as[TaskHierarchy]
        _ <- expect(hierarchy.task.id == taskId).failFast
        _ <- expect(hierarchy.subtasks.length == 1).failFast

      } yield success
    }
  }

  test("Error handling integration test") {
    withFullApplication { app =>
      for {
        user <- UserGenerators.userGen.sample
        authedUser = AuthedUser(user.id, user.name, user.email)
        nonExistentTaskId <- TaskGenerators.taskIdGen.sample

        // Test 404 error for non-existent task
        response <- app
          .taskContentRoutes
          .run(
            Request[IO](
              Method.GET,
              uri"/tasks" / nonExistentTaskId.value.toString / "comments",
            ) -> authedUser
          )
          .value

        _ <- expect(response.isDefined).failFast
        _ <- expect(response.get.status == Status.NotFound).failFast

        // Test validation error for invalid move
        invalidMoveRequest = TaskMoveRequest(TaskStatus.InProgress, -1)

        moveResponse <- app
          .kanbanRoutes
          .run(
            Request[IO](
              Method.PUT,
              uri"/kanban" / "task" / nonExistentTaskId.value.toString / "move",
            )
              .withEntity(invalidMoveRequest) -> authedUser
          )
          .value

        _ <- expect(moveResponse.isDefined).failFast
        _ <- expect(moveResponse.get.status == Status.BadRequest).failFast

      } yield success
    }
  }

  private def withFullApplication[A](f: TestApplication => IO[A]): IO[A] = {
    // This would create a full application with all repositories, services, and routes
    // For now, this is a simplified version
    val app = TestApplication()
    f(app)
  }

  private case class TestApplication(
      taskRoutes: AuthedRoutes[AuthedUser, IO] = ???,
      taskContentRoutes: AuthedRoutes[AuthedUser, IO] = ???,
      kanbanRoutes: AuthedRoutes[AuthedUser, IO] = ???,
      timeTrackingRoutes: AuthedRoutes[AuthedUser, IO] = ???,
      dependencyRoutes: AuthedRoutes[AuthedUser, IO] = ???,
    )
}
