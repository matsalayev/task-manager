package tm.generators

import java.time.{LocalDate, LocalDateTime}

import tm.domain.{PersonId, TaskId, WorkId}
import tm.domain.time._
import tm.test.generators.CommonGenerators

object TimeTrackingGenerators extends CommonGenerators {

  val workModeGen = sample(
    WorkMode.Office,
    WorkMode.Remote,
    WorkMode.Hybrid
  )

  val breakReasonGen = sample(
    BreakReason.Lunch,
    BreakReason.Coffee,
    BreakReason.Meeting,
    BreakReason.Personal,
    BreakReason.Toilet,
    BreakReason.Other
  )

  val activityTypeGen = sample(
    ActivityType.SessionStart,
    ActivityType.SessionEnd,
    ActivityType.BreakStart,
    ActivityType.BreakEnd,
    ActivityType.TaskStart,
    ActivityType.TaskEnd,
    ActivityType.ModeChange
  )

  val enhancedWorkSessionGen = for {
    id <- WorkId.gen
    userId <- PersonId.gen
    startTime <- localDateTime
    endTime <- option(localDateTime)
    workMode <- workModeGen
    isRunning <- boolean
    totalMinutes <- posInt(0, 480)
    breakMinutes <- posInt(0, 120)
    productiveMinutes <- posInt(0, 360)
    description <- option(nonEmptyString.map(_.value))
    location <- option(nonEmptyString.map(_.value))
    createdAt <- zonedDateTime
  } yield EnhancedWorkSession(
    id = id,
    userId = userId,
    startTime = startTime,
    endTime = endTime,
    workMode = workMode,
    isRunning = isRunning,
    totalMinutes = totalMinutes,
    breakMinutes = breakMinutes,
    productiveMinutes = productiveMinutes,
    description = description,
    location = location,
    createdAt = createdAt
  )

  val timeEntryGen = for {
    id <- TimeEntryId.gen
    userId <- PersonId.gen
    taskId <- option(TaskId.gen)
    workSessionId <- option(WorkId.gen)
    startTime <- localDateTime
    endTime <- option(localDateTime)
    duration <- option(posInt(1, 480))
    description <- nonEmptyString.map(_.value)
    isRunning <- boolean
    isBreak <- boolean
    breakReason <- option(breakReasonGen)
    isManual <- boolean
    createdAt <- zonedDateTime
    updatedAt <- zonedDateTime
  } yield TimeEntry(
    id = id,
    userId = userId,
    taskId = taskId,
    workSessionId = workSessionId,
    startTime = startTime,
    endTime = endTime,
    duration = duration,
    description = description,
    isRunning = isRunning,
    isBreak = isBreak,
    breakReason = breakReason,
    isManual = isManual,
    createdAt = createdAt,
    updatedAt = updatedAt
  )

  val dailyTimeReportGen = for {
    userId <- PersonId.gen
    date <- localDate
    totalWorkedMinutes <- posInt(0, 600)
    productiveMinutes <- posInt(0, 480)
    breakMinutes <- posInt(0, 120)
    tasksWorked <- posInt(0, 20)
    workMode <- option(workModeGen)
    startTime <- option(localDateTime)
    endTime <- option(localDateTime)
    overtimeMinutes <- posInt(0, 180)
    isHoliday <- boolean
  } yield DailyTimeReport(
    userId = userId,
    date = date,
    totalWorkedMinutes = totalWorkedMinutes,
    productiveMinutes = productiveMinutes,
    breakMinutes = breakMinutes,
    tasksWorked = tasksWorked,
    workMode = workMode,
    startTime = startTime,
    endTime = endTime,
    overtimeMinutes = overtimeMinutes,
    isHoliday = isHoliday
  )

  val startWorkSessionRequestGen = for {
    workMode <- workModeGen
    location <- option(nonEmptyString.map(_.value))
    description <- option(nonEmptyString.map(_.value))
  } yield StartWorkSessionRequest(workMode, location, description)

  val startTimerRequestGen = for {
    taskId <- option(TaskId.gen)
    description <- nonEmptyString.map(_.value)
  } yield StartTimerRequest(taskId, description)

  val startBreakRequestGen = for {
    reason <- breakReasonGen
    description <- option(nonEmptyString.map(_.value))
  } yield StartBreakRequest(reason, description)

  val manualTimeEntryRequestGen = for {
    taskId <- option(TaskId.gen)
    startTime <- localDateTime
    durationMinutes <- posInt(1, 480)
    description <- nonEmptyString.map(_.value)
  } yield ManualTimeEntryRequest(taskId, startTime, durationMinutes, description)

  private val localDateTime = for {
    year <- int(2020, 2030)
    month <- int(1, 12)
    day <- int(1, 28)
    hour <- int(0, 23)
    minute <- int(0, 59)
  } yield LocalDateTime.of(year, month, day, hour, minute)

  private val localDate = for {
    year <- int(2020, 2030)
    month <- int(1, 12)
    day <- int(1, 28)
  } yield LocalDate.of(year, month, day)
}